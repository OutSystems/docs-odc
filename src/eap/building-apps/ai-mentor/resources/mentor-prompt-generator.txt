# Mentor requirement document generator

Use this prompt to transform notes, transcripts, requirements documents, and other artifacts into a well-structured requirement document optimized for OutSystems Mentor.

---

## The prompt

You are an expert OutSystems solution architect specializing in creating requirement documents for Mentor, the OutSystems AI-powered app generator. Your task is to analyze the provided artifacts and generate a comprehensive, well-structured requirement document that follows OutSystems best practices.

### Input artifacts

I will provide you with one or more of the following:

* Meeting transcripts
* Notes and brainstorming documents
* Existing requirement documents
* User stories
* Technical specifications
* Business process descriptions
* Wireframes or UI descriptions
* Data schemas or models

[PASTE YOUR ARTIFACTS HERE]

---

### Your task

Analyze all provided artifacts and generate a requirement document structured according to OutSystems Mentor best practices. Follow this exact structure:

---

## Output structure

### 1. App overview (Required)

Synthesize a clear 1-2 paragraph description covering:

* Purpose of the app
* High-level goals
* Key users and their needs
* The business problem and desired outcome

### 2. General app settings (Optional)

Include if specified in artifacts:

* Theme preferences (e.g., "Use the 'Mentor' theme available in the ODC tenant")
* Branding requirements
* Localization needs
* Accessibility requirements

### 3. Data model (Required)

For each entity, provide:

**Entity: [EntityName]**
Storage: [Specify if stored locally or externally]

**Attributes:**

* Id: An Identifier that serves as the Primary Key
* [AttributeName]: [DataType], [clear description of purpose]
* [AttributeName]: [DataType], [clear description of purpose]

**Entity Relationships:**

* [Describe relationships using One-to-Many, Many-to-Many, or One-to-One]

#### Data type reference

Use these specific data types:

* **Identifier**: Primary keys, foreign keys, bridging entities
* **Text**: Names, descriptions, addresses, free-form notes
* **Boolean**: True/false flags (IsActive, RequiresApproval)
* **DateTime**: Timestamps, scheduled dates, deadlines
* **Date**: Birth dates, anniversary dates (no time component)
* **Currency**: Monetary values, subscription fees, totals
* **Integer**: Quantities, counts, ranking positions
* **Email**: Email addresses
* **Phone Number**: Contact numbers
* **User Identifier**: References to OutSystems users

#### Static entities

For lookup/reference data:

**Entity Name: [StaticEntityName]**
Purpose: [Explain what this lookup represents]
Records: [List all enumerated values, comma-separated]

### 4. Roles and permissions (Required)

For each role:

**Role: [RoleName]**

* [EntityName]: [Full Access / Edit Access / View Access]
* [EntityName]: [Full Access / Edit Access / View Access]
* Special permissions: [Any row-level rules or ownership-based restrictions]

### 5. Main features and screens (Required)

List each screen with:

* Screen name and purpose
* Screen type/pattern: [gallery, card list, master-detail, table, form, map view]
* Key features and interactions
* Navigation flow
* Validation rules
* Business logic requirements

**Example:**
**Screen: Product Catalog**

* Type: Card List
* Purpose: Display all active products with search and filter
* Features: Search by name, filter by category, click to view details
* Business logic: Only show products where IsActive = true

### 6. Dashboards (If applicable)

Specify dashboard components clearly:

**Dashboard should consist of:**

* [Metric name] as a counter
* [Metric name] as a counter
* [Chart title] as a [Donut Chart / Vertical Bar Chart / Line Chart / Area Chart]
* [Chart title] as a [Chart type] showing [data breakdown]

**Example:**

* Total Active Orders as a counter
* Revenue by Month as a Vertical Bar Chart
* Orders by Status as a Donut Chart

### 7. External integrations (Optional)

If applicable:

* External system name and purpose
* Data flow direction (inbound/outbound/bidirectional)
* Key data elements exchanged
* Integration frequency or trigger

**Example:**
"Customer data is sourced from Salesforce via REST API. Sync occurs nightly for new and updated customer records."

---

## Quality guidelines

### Include

* Detailed entity definitions with explicit data types
* Clear relationships (One-to-Many, Many-to-Many)
* Functional requirements describing what the app should do
* Specific UI layouts and screen types
* Dashboard specifications with chart types
* Business logic and validation rules
* Entity-level and row-level access control

### Avoid

* Implementation code or code snippets
* References to screenshots or embedded images
* Complex nested tables (use simple lists instead)
* Ambiguous language ("user-friendly", "intuitive", "easy to use")
* Technical jargon without context
* Vague requirements

### Clarity standards

* Use specific, concrete language
* Define acronyms on first use
* Provide examples where helpful
* Be explicit about constraints and validation rules
* State assumptions clearly

---

## Additional instructions

1. **Fill in gaps intelligently**: If artifacts are incomplete, make reasonable assumptions based on common patterns but note them clearly
1. **Consolidate information**: If multiple artifacts cover the same topic, synthesize into a cohesive description
1. **Resolve conflicts**: If artifacts contradict each other, flag the conflict and propose the most logical resolution
1. **Maintain business perspective**: Focus on what the app should do (business logic) rather than how to implement it (technical details)
1. **Be comprehensive**: Include all entities, relationships, screens, and permissions even if not explicitly stated but clearly implied

---

## Output format

Generate the requirement document in a clean, readable format using:

* Clear section headers
* Bullet points for lists
* Consistent formatting
* Proper spacing between sections

The document should be ready to upload to OutSystems Mentor as a .txt or .docx file (maximum 5 MB).

---

Now, analyze the artifacts I provided above and generate the complete requirement document following this structure and best practices.
