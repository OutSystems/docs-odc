---
guid: aec0cd3b-dcd4-4077-b0c0-04e987bdb690
locale: en-us
summary: Create AI agents in OutSystems Developer Cloud (ODC) using function calling to fulfill complex user requests with dynamic action orchestration.
figma:
coverage-type:
  - understand
topic:
app_type: reactive web apps,mobile apps
platform-version: odc
audience:
  - full stack developers
tags: ai agents, function calling, agentcore, action calling, outsystems developer cloud
outsystems-tools:
  - odc studio
helpids:
---
# AI agent actions

<div class="info" markdown="1">

Agentic app creation is available through the Early Access Program. Click here to [apply for the Early Access Program](https://www.outsystems.com/low-code-platform/agentic-ai-workbench/eap-agent-workbench/). 

</div>

Function calling is the ability of an [AI model](ai-models.md) to go beyond generating text and intelligently use tools to perform actions or get data. With function calling, [you can build AI agents](create-agent.md)  that interact with your apps and data sources to fulfill complex user requests.

## Action calling 

In ODC, the `AgentCore` element within an `AgentTask` flow orchestrates this process. When an agent is triggered, it uses an AI model's reasoning to dynamically decide the best course of action. This can involve calling a single Server Action, a sequence of different actions, or the same action multiple times.

The AI model decides based on the context you provide, which includes:

* The end-user's prompt at runtime.  
* The [System Prompt](agentic-apps.md#system-prompts) you define to instruct the agent on its behavior and goals.  
* The metadata of the available actions (their names, descriptions, and input parameters).

The core of this functionality lies in how you define actions for your agent.

* **Actions are Server Actions**: In the context of an AI agent, an action is a standard Server Action. You grant the agent the ability to use these actions to perform its tasks.  
* **Agent autonomy**: You provide the agent with a set of available actions. The AI model autonomously decides which action (or sequence of actions) is appropriate by analyzing the prompts and the purpose of each action you've exposed.

Providing actions is optional. If you don't provide any Server Actions, the agent relies exclusively on the AI model's internal knowledge to generate responses.

### Implementation considerations

To build reliable and effective agents, keep the following in mind. 

#### Indicate AI-generated content

The **Generated by AI** setting for a parameter instructs the AI model to use its reasoning to dynamically determine and provide the value for that specific input at runtime.

Instead of manually assigning a variable or a hardcoded value to an input, you can delegate the task of filling in the parameter to the AI. The model analyzes the complete context of the conversation to infer the correct value.

#### Write detailed and accurate descriptions

The AI model's ability to choose the correct action depends entirely on the text descriptions you provide for the Server Action and its parameters. The model has no other way of understanding what an action does.

* **Action description**: Clearly describe the action’s purpose, what it accomplishes, and when to use it.  
* **Parameter descriptions**: Explain what each input and output represents and provide context on expected values or formats.

The more detailed and clear your descriptions are, the better the model’s reasoning is, leading to more accurate action calls. 

#### Guide the Call Condition

The **Call Condition** setting is a safeguard within the **Action calling settings**. Its purpose is to prevent an AI agent from getting stuck in a loop or consuming excessive resources during runtime. You can define specific limits that, once reached, stop the agent from calling any more actions for the current task.

The agent terminates its reasoning loop when it meets a Call Condition. The agent then generates a final response to the user based on the information gathered up to that point. This ensures every agent task concludes, which prevents runaway costs and improves app stability.

You can set one or more of the following conditions:

* Number of loops  
* Number of actions called  
* Amount of tokens consumed
